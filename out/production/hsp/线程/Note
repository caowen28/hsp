进程：运行中的程序，是一个程序的一次执行过程
线程：由进程创建，是进程的实体
     一个进程可以有多个线程

     线程：单线程：同一时刻只能执行一个线程
          多线程：同一时刻运行多个线程

     并发：同一时刻多个任务交替执行，单核cpu实现的多任务就是并发
     并行：同一时刻多个任务同时执行，多核cpu可以实现并行

     创建线程的两种方式:1.继承thread类，重写run方法（其实thread类实现runnable接口）
                     2.实现runnable接口，重写run方法

     当main线程启动一个子线程时，主线程不会阻塞，会继续执行

     使用JConsole监控线程的执行情况

     真正实现多线程的效果是start0（）而不是run

     start()方法调用start0（）方法后，该线程并不一定立马执行，只是将该线程变为可运行状态，具体什么时候执行取决于cpu，由cpu调用

     java是单继承机制，如果一个类继承其父类，那么它便无法继承Thread类也就无法创建线程，为此便有了第二种创建线程的方式即实现runnable接口

     线程常用的方法：
        第一组：
        setName   //设置线程名
        getName   //返回线程名
        start     //使该线程开始执行，jvm调用底层start0()      start底层会创建新的线程，调用run（run是一个简单的方法，不会创建线程）
        run       //调用线程对象run方法
        setPriority  设置线程优先级
        getPriority  获取线程优先级
        sleep   使线程进入休眠状态，可指定毫秒数
        interrup   中断线程，不是终止线程

        第二组：
        yield  线程的礼让，让出cpu，让其他线程执行，但礼让时间不确定，所以也不一定会礼让成功
        join    线程的插队，插队的线程一旦插队成功则肯定先执行完插入的线程所有任务

        用户线程和守护线程
          用户线程：工作线程，当线程的任务执行完成或通知方式结束
          守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
          常见的守护线程：垃圾回收机制

        线程的生命周期：
            jdk中用Thread。State枚举表示线程的几种状态
            NEW             未启动的线程处于此状态
            RUNNABLE        在java虚拟机中执行的线程处于此状态
            BLOCKED         被阻塞等待监听器锁定的线程处于此状态
            WAITING         正在等待另一个线程执行特定动作的线程处于此状态
            TIMED_WAITING   正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
            TERMINATED      已退出的线程处于此状态